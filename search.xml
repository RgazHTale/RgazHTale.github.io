<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux文件操作函数</title>
      <link href="/2022/10/03/Linux%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0/"/>
      <url>/2022/10/03/Linux%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux标准IO函数"><a href="#Linux标准IO函数" class="headerlink" title="Linux标准IO函数"></a>Linux标准IO函数</h2><p><img src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img@master/img/202210032207342.png" alt="img"></p><h3 id="int-open-const-char-pathname-int-flags"><a href="#int-open-const-char-pathname-int-flags" class="headerlink" title="int open(const char *pathname, int flags);"></a>int open(const char *pathname, int flags);</h3><p>const char *pathname：指定的路径。</p><p>fint flags：定义的一些宏，标记，代表权限。从O_RDONLY、O_WRONLY、O_RDWR中选择一个。需要加其它权限，只需要和前面的做<strong>或运算</strong>即可。</p><p><strong>作用：</strong>打开一个已经存在的文件。</p><p>返回值：执行成功返回一个文件描述符，失败返回-1。</p><h3 id="errno"><a href="#errno" class="headerlink" title="errno"></a>errno</h3><p>errno<strong>：</strong>属于Linux系统函数库，是库里面的一个全局变量，记录的是最近的错误号。可使用标准C</p><p>库（#include &lt;stdio.h&gt;）中的**perror()**打印。</p><h3 id="int-open-const-char-pathname-int-flags-mode-t-mode"><a href="#int-open-const-char-pathname-int-flags-mode-t-mode" class="headerlink" title="int open(const char *pathname, int flags, mode_t mode);"></a><strong>int open(const char *pathname, int flags, mode_t mode);</strong></h3><p>mode_t mode：八进制的数，表示用户对创建出的新的文件的操作权限。<strong>最终的权限是mode &amp; ~umask。</strong>umask会用来抹去一些权限，防止用户误操作。</p><p><strong>作用：创建新文件</strong>。</p><h3 id="ssize-t-read-int-fd-void-buf-size-t-count"><a href="#ssize-t-read-int-fd-void-buf-size-t-count" class="headerlink" title="ssize_t read(int fd, void *buf, size_t count);"></a>ssize_t read(int fd, void *buf, size_t count);</h3><p>void <em>buf：缓冲区。这是一个*<em>传出参数。</em></em></p><p>size_t count：指定的数组大小。</p><p><strong>作用：</strong>读取文件。</p><p>返回值：返回读到的字节数量。返回0即代表读到文件末尾，返回-1则代表读取失败，并设置errno。ssize_t实际上就是是int类型，typedef int ssize_t。</p><h3 id="void-类型的形参"><a href="#void-类型的形参" class="headerlink" title="void *类型的形参"></a>void *类型的形参</h3><p>当几个函数功能差不多，但是受限于参数类型，此时可以使用void *类型传递参数，然后在函数内部对类型进行判断，切换到不同数据类型处理不同的数据。 void不是此时不是空的含义，而是“任意”的含义，可以将其进行类型转换，也就是泛型。</p><h3 id="ssize-t-write-int-fd-void-buf-size-t-count"><a href="#ssize-t-write-int-fd-void-buf-size-t-count" class="headerlink" title="ssize_t write(int fd, void *buf, size_t count);"></a>ssize_t write(int fd, void *buf, size_t count);</h3><p>void *buf：缓冲区。这是一个<strong>传入参数</strong>。</p><p>size_t count：指定的数组大小。</p><p><strong>作用：</strong>写入文件。</p><p>返回值：写入成功返回实际写入的数据大小，失败返回-1，并设置errno。</p><h3 id="sizefof与strlen"><a href="#sizefof与strlen" class="headerlink" title="sizefof与strlen"></a>sizefof与strlen</h3><p>sizeof是C语言的一<strong>种单目操作符，</strong>如C语言的其他操作符++、–等。sizeof操作符以字节形式给出了其操作数的存储大小。操作数可以是一个<a href="https://so.csdn.net/so/search?q=%E8%A1%A8%E8%BE%BE%E5%BC%8F&spm=1001.2101.3001.7020">表达式</a>或括在括号内的类型名。操作数的存储大小由操作数的类型决定。</p><p>进行IO时，对数组是sizeof，对char*字符串是strlen。</p><h3 id="作业1：实现文件拷贝功能"><a href="#作业1：实现文件拷贝功能" class="headerlink" title="作业1：实现文件拷贝功能"></a>作业1：实现文件拷贝功能</h3><p><strong>已完成</strong></p><h3 id="off-t-lseek-int-fd-off-t-offset-int-whence"><a href="#off-t-lseek-int-fd-off-t-offset-int-whence" class="headerlink" title="off_t lseek(int fd, off_t offset, int whence);"></a>off_t lseek(int fd, off_t offset, int whence);</h3><p>off_t offset：偏移量。</p><p>Int whence：</p><ul><li><p>SEEK_CUR：设置文件指针偏移量，从当前位置；</p></li><li><p>SEEK_SET：设置文件指针的偏移量，从文件开头；</p></li><li><p>SEEK_END：设置文件指针偏移量，从文件末尾。</p></li></ul><p><strong>作用：</strong></p><ol><li>移动文件指针到文件开头；</li></ol><pre><code class="C">lseek(fd, 0, SEEK_SET);</code></pre><ol><li>获取当前文件指针的位置；</li></ol><pre><code class="C">lseek(fd, 0, SEEK_CUR);</code></pre><ol><li>获取文件长度</li></ol><pre><code class="C">lseek(fd, 0, SEEK_END);</code></pre><ol><li>拓展文件长度</li></ol><pre><code class="C">// 当前文件10b，增加100blseek(fd, 100, SEEK_END);</code></pre><p><strong>返回值：</strong>返回最终所在的位置，返回文件指针的位置。</p><p><img src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img@master/img/202210032207651.png" alt="img"></p><h3 id="int-stat-const-char-pathname-struct-stat-statbuf"><a href="#int-stat-const-char-pathname-struct-stat-statbuf" class="headerlink" title="int stat(const char *pathname, struct stat *statbuf);"></a>int stat(const char *pathname, struct stat *statbuf);</h3><p>struct stat *statbuf：这是一个传出参数，是一个用于记录文件信息的结构体。</p><p><strong>作用：</strong>查看文件信息。</p><p>返回值：成功返回0，失败返回-1，设置errno。</p><p><img src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img@master/img/202210032207189.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img@master/img/202210032207515.png" alt="img"></p><h3 id="int-lstat-const-char-pathname-struct-stat-statbuf"><a href="#int-lstat-const-char-pathname-struct-stat-statbuf" class="headerlink" title="int lstat(const char *pathname, struct stat *statbuf);"></a>int lstat(const char *pathname, struct stat *statbuf);</h3><p><strong>作用：</strong>获取软链接本身的信息，stat会获取软链接指向的文件的信息。</p><h3 id="C-C-语言数组"><a href="#C-C-语言数组" class="headerlink" title="C/C++语言数组"></a>C/C++语言数组</h3><p>声明时是指的元素个数，列如：</p><pre><code class="C">int arry[10] = &#123;0&#125;;</code></pre><p>此时指的是数组有<strong>10个元素</strong>，数组下标最多为9。</p><h2 id="文件属性相关的操作函数"><a href="#文件属性相关的操作函数" class="headerlink" title="文件属性相关的操作函数"></a>文件属性相关的操作函数</h2><p><img src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img@master/img/202210032207809.png" alt="img"></p><h3 id="int-access-const-char-pathname-int-mode"><a href="#int-access-const-char-pathname-int-mode" class="headerlink" title="int access(const char *pathname, int mode);"></a>int access(const char *pathname, int mode);</h3><p>Int mode：</p><ul><li><p>R_OK：判断是否有读权限；</p></li><li><p>W_OK：判断是否有写权限；</p></li><li><p>X_OK：判断是否有执行权限；</p></li><li><p>F_OK：判断文件是否存在。</p></li></ul><p><strong>作用：</strong>判断某个文件是否有某个权限，或者检查某个文件是否存在。</p><p>返回值：成功返回0，失败返回-1.</p><h3 id="int-chmod-const-char-pathname-mode-t-mode"><a href="#int-chmod-const-char-pathname-mode-t-mode" class="headerlink" title="int chmod(const char *pathname, mode_t mode);"></a>int chmod(const char *pathname, mode_t mode);</h3><p>mode_t mode：需要修改的权限值，八进制的数。</p><p>返回值：成功返回0，失败返回-1.</p><h3 id="int-chown-const-char-pathname-uid-t-owner-gid-t-group"><a href="#int-chown-const-char-pathname-uid-t-owner-gid-t-group" class="headerlink" title="int chown(const char *pathname, uid_t owner, gid_t group);"></a>int chown(const char *pathname, uid_t owner, gid_t group);</h3><p>作用：修改所有者和所在组。</p><h3 id="int-truncate-const-char-path-off-t-length"><a href="#int-truncate-const-char-path-off-t-length" class="headerlink" title="int truncate(const char *path, off_t length);"></a>int truncate(const char *path, off_t length);</h3><p>off_t length：指定文件的最终大小。</p><p>作用：缩减或扩展文件至指定的大小。</p><p>返回值：成功返回0，失败返回-1。</p><h2 id="目录操作函数"><a href="#目录操作函数" class="headerlink" title="目录操作函数"></a>目录操作函数</h2><p><img src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img@master/img/202210032207403.png" alt="img"></p><h3 id="int-mkdir-const-char-pathname-mode-t-mode"><a href="#int-mkdir-const-char-pathname-mode-t-mode" class="headerlink" title="int mkdir(const char *pathname, mode_t mode);"></a>int mkdir(const char *pathname, mode_t mode);</h3><p>mode_t mode：权限，八进制的数。</p><p>作用：创建一个目录。</p><h3 id="int-rmdir-const-char-pathname"><a href="#int-rmdir-const-char-pathname" class="headerlink" title="int rmdir(const char *pathname);"></a>int rmdir(const char *pathname);</h3><p>作用：删除一个<strong>空目录</strong>。</p><h3 id="int-rename-const-char-oldpath-const-char-newpath"><a href="#int-rename-const-char-oldpath-const-char-newpath" class="headerlink" title="int rename(const char *oldpath, const char *newpath);"></a>int rename(const char *oldpath, const char *newpath);</h3><p>作用：重命名。</p><h3 id="int-chdir-const-char-path"><a href="#int-chdir-const-char-path" class="headerlink" title="int chdir(const char *path);"></a>int chdir(const char *path);</h3><p>const char *path：需要修改的工作目录。</p><p>作用：修改进程的工作目录。</p><h3 id="char-getcwd-char-buf-size-t-size"><a href="#char-getcwd-char-buf-size-t-size" class="headerlink" title="char *getcwd(char *buf, size_t size);"></a>char *getcwd(char *buf, size_t size);</h3><p>char *buf：存储的路径，指向的是一个数组，传出参数。</p><p>size_t size：数组的大小。</p><p>作用：获取当前工作目录。</p><p>返回值：返回的指向的一块内存，这个数据就是第一个参数。</p><h2 id="目录遍历函数"><a href="#目录遍历函数" class="headerlink" title="目录遍历函数"></a>目录遍历函数</h2><p><img src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img@master/img/202210032208453.png" alt="img"></p><h3 id="DIR-opendir-const-char-name"><a href="#DIR-opendir-const-char-name" class="headerlink" title="DIR *opendir(const char *name);"></a>DIR *opendir(const char *name);</h3><p>const char *name：需要打开的目录名称。</p><p>作用：打开一个目录流。最开始目录流在第一个文件，读的时候会往后移动。</p><p>返回值：返回一个目录流信息，实际上为一个结构体指针。</p><h3 id="struct-dirent-readdir-DIR-dirp"><a href="#struct-dirent-readdir-DIR-dirp" class="headerlink" title="struct dirent *readdir(DIR *dirp);"></a>struct dirent *readdir(DIR *dirp);</h3><p>DIR *dirp：是通过opendir返回的结果。</p><p>作用：用来读取目录中的数据。</p><p>返回值：一个结构体，代表读取到文件的信息。<strong>如果读取到末尾，返回NULL。失败了，则返回NULL，并设置errno</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img@master/img/202210032207053.png" alt="img"></p><h3 id="int-closedir-DIR-dirp"><a href="#int-closedir-DIR-dirp" class="headerlink" title="int closedir(DIR *dirp);"></a>int closedir(DIR *dirp);</h3><p>作用：关闭目录流。</p><h2 id="dup、dup2函数"><a href="#dup、dup2函数" class="headerlink" title="dup、dup2函数"></a>dup、dup2函数</h2><p><img src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img@master/img/202210032208726.png" alt="img"></p><h3 id="int-dup-int-oldfd"><a href="#int-dup-int-oldfd" class="headerlink" title="int dup(int oldfd);"></a>int dup(int oldfd);</h3><p>作用：复制一个文件描述符，值为文件描述符表中最小的没有被使用的数字。</p><p>返回值：返回一个新的文件描述符，指向同一个文件，错误返回-1。</p><h3 id="int-dup2-int-oldfd，-int-newfd"><a href="#int-dup2-int-oldfd，-int-newfd" class="headerlink" title="int dup2(int oldfd， int newfd);"></a>int dup2(int oldfd， int newfd);</h3><p>作用：重定向文件描述符。newfd会做close，然后指向oldfd所指向的文件。oldfd必须是一个有效的文件描述符。</p><h2 id="int-fcntl-int-fd-int-cmd-…-arg"><a href="#int-fcntl-int-fd-int-cmd-…-arg" class="headerlink" title="int fcntl(int fd, int cmd, … /* arg */ );"></a>int fcntl(int fd, int cmd, … /* arg */ );</h2><p>int fd：文件描述符。</p><p>int cmd：表示对文件描述符进行如何操作。</p><ul><li>F_DFPFD：复制文件描述符，复制的是第一个参数fd，得到一个新的文件描述符</li></ul><pre><code class="C">int ret = fcntl(fd, F_DFPFD);</code></pre><ul><li><p>F_GETFL：获取指定文件描述符文件状态flag，获取的flag和我们通过open函数传递的flag是同一个东西。<strong>返回值就是flag。</strong></p></li><li><p>F_SETFL：设置文件描述符文件状态flag，必选项，O_RDONLY、O_WRONLY、O_RDWR，这三个是不可以修改的。可选项，O_APPEND、O_NONBLOCK，这些可以通过或运算添加。<strong>所以修改步骤</strong>是先通过<strong>F_GETFL</strong>得到flag，然后再把这个flag和要添加的可选项做或运算。NONBLOCK表示<strong>非阻塞</strong>。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux系统调用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux文件描述符到底是什么？</title>
      <link href="/2022/09/28/Linux%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
      <url>/2022/09/28/Linux%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux文件描述符到底是什么？"><a href="#Linux文件描述符到底是什么？" class="headerlink" title="Linux文件描述符到底是什么？"></a>Linux文件描述符到底是什么？</h1><p>本文源自<a href="http://c.biancheng.net/view/3066.html">Linux文件描述符到底是什么？ (biancheng.net)</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="http://c.biancheng.net/view/2852.html">Linux 中一切皆文件</a>，比如 <a href="http://c.biancheng.net/cplus/">C++</a> 源文件、视频文件、Shell脚本、可执行文件等，就连键盘、显示器、鼠标等硬件设备也都是文件。</p><p>一个 Linux 进程可以打开成百上千个文件，为了表示和区分已经打开的文件，Linux 会给每个文件分配一个编号（一个 ID），这个编号就是一个整数，被称为文件描述符（File Descriptor）。</p><p>这只是一个形象的比喻，为了让读者容易理解我才这么说。如果你也仅仅理解到这个层面，那不过是浅尝辄止而已，并没有看到文件描述符的本质。</p><p>本篇文章的目的就是拨云见雾，从底层实现的角度来给大家剖析一下文件描述符，看看文件描述如到底是如何表示一个文件的。</p><p>不过，阅读本篇文章需要你有C语言编程基础，至少要理解数组、指针和结构体；如果理解内存，那就更好了，看了这篇文章你会醍醐灌顶。</p><p>好了，废话不多说，让我们马上进入正题吧。</p><h2 id="let’s-go"><a href="#let’s-go" class="headerlink" title="let’s go"></a>let’s go</h2><p>一个 Linux 进程启动后，会在内核空间中创建一个 PCB 控制块，PCB 内部有一个文件描述符表（File descriptor table），记录着当前进程所有可用的文件描述符，也即当前进程所有打开的文件。</p><p>内核空间是虚拟地址空间的一部分，想死磕的读者请猛击《<a href="http://c.biancheng.net/c/140/">C语言内存精讲</a>》，不想纠缠细节的读者可以这样理解：进程启动后要占用内存，其中一部分内存分配给了文件描述符表。</p><p>除了文件描述符表，系统还需要维护另外两张表：</p><ul><li>打开文件表（Open file table）</li><li>i-node 表（i-node table）</li></ul><p>文件描述符表每个进程都有一个，打开文件表和 i-node 表整个系统只有一个，它们三者之间的关系如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img@master/img/202209281617318.png" alt="image-20220928161749247"></p><p>从质上讲，这三种表都是结构体数组，0、1、2、73、1976 等都是数组下标。表头只是我自己添加的注释，数组本身是没有的。实线箭头表示指针的指向，虚线箭头是我自己添加的注释。</p><p>**ps:**图中前两个应该是文件描述符表，文件描述符只是数字下标！</p><p><strong>你看，文件描述符只不过是一个数组下标吗！</strong></p><p>通过文件描述符，可以找到文件指针，从而进入打开文件表。该表存储了以下信息：</p><ul><li>文件偏移量，也就是文件内部指针偏移量。调用 read() 或者 write() 函数时，文件偏移量会自动更新，当然也可以使用 lseek() 直接修改。</li><li>状态标志，比如只读模式、读写模式、追加模式、覆盖模式等。</li><li>i-node 表指针。</li></ul><p>然而，要想真正读写文件，还得通过打开文件表的 i-node 指针进入 i-node 表，该表包含了诸如以下的信息：</p><ul><li>文件类型，例如常规文件、套接字或 FIFO。</li><li>文件大小。</li><li>时间戳，比如创建时间、更新时间。</li><li>文件锁。</li></ul><p>对上图的进一步说明：</p><ul><li>在进程 A 中，文件描述符 1 和 20 都指向了同一个打开文件表项，标号为 23（指向了打开文件表中下标为 23 的数组元素），这可能是通过调用 dup()、dup2()、fcntl() 或者对同一个文件多次调用了 open() 函数形成的。</li><li>进程 A 的文件描述符 2 和进程 B 的文件描述符 2 都指向了同一个文件，这可能是在调用 fork() 后出现的（即进程 A、B 是父子进程关系），或者是不同的进程独自去调用 open() 函数打开了同一个文件，此时进程内部的描述符正好分配到与其他进程打开该文件的描述符一样。</li><li>进程 A 的描述符 0 和进程 B 的描述符 3 分别指向不同的打开文件表项，但这些表项均指向 i-node 表的同一个条目（标号为 1976）；换言之，它们指向了同一个文件。发生这种情况是因为每个进程各自对同一个文件发起了 open() 调用。同一个进程两次打开同一个文件，也会发生类似情况。 </li></ul><p>有了以上对文件描述符的认知，我们很容易理解以下情形：</p><ul><li>同一个进程的不同文件描述符可以指向同一个文件；</li><li>不同进程可以拥有相同的文件描述符；</li><li>不同进程的同一个文件描述符可以指向不同的文件（一般也是这样，除了 0、1、2 这三个特殊的文件）；</li><li>不同进程的不同文件描述符也可以指向同一个文件。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>文件描述符实际上就是文件描述符表的下标，每个进程有自己的文件描述符表，但是<strong>打开文件表</strong>和<strong>i-node表</strong>整个系统只有一个。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Qt配置MCVS2017编译环境</title>
      <link href="/2022/05/22/Qt%E9%85%8D%E7%BD%AEMCVS2017%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/"/>
      <url>/2022/05/22/Qt%E9%85%8D%E7%BD%AEMCVS2017%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h1 id="开发环境配置详细版"><a href="#开发环境配置详细版" class="headerlink" title="开发环境配置详细版"></a>开发环境配置详细版</h1><h2 id="一、所需依赖"><a href="#一、所需依赖" class="headerlink" title="一、所需依赖"></a>一、所需依赖</h2><ol><li>Qt Creator</li><li>Visual Studio Comunity 2017</li></ol><h2 id="二、Qt-Creator的安装"><a href="#二、Qt-Creator的安装" class="headerlink" title="二、Qt Creator的安装"></a>二、Qt Creator的安装</h2><p>​    这里需要注意的是，我们需要用到MSVC2017的编译器，然而<strong>Qt5.12</strong>之后的版本是不支持MSVC2017编译器的，所以我们必须选择5.12之前的版本才可以，这里我选择的是上一代的最后一个版本5.14.2。</p><p>​    安装步骤如下：</p><ol><li>下载Qt在线安装工具:<a href="https://mirrors.tuna.tsinghua.edu.cn/qt/official_releases/online_installers/">https://mirrors.tuna.tsinghua.edu.cn/qt/official_releases/online_installers/</a></li></ol><p>​    选择windos系统的版本下载</p><p><img src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img/img/image-20220522144935599.png" alt="image-20220522144935599"></p><ol start="2"><li><p>直接运行该程序，登录账号</p><p><img src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img/img/image-20220522145106114.png" alt="image-20220522145106114"></p></li><li><p>勾选开源协议，并确认，是否商业！</p></li></ol><p>​    <img src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img/img/image-20220522145134915.png" alt="image-20220522145134915"></p><p><img src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img/img/image-20220522145206585.png" alt="image-20220522145206585"></p><p><img src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img/img/image-20220522145217075.png" alt="image-20220522145217075"></p><ol start="4"><li>选择路径和安装方式</li></ol><p><img src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img/img/image-20220522145305974.png" alt="image-20220522145305974"></p><ol start="5"><li>选择要下载的组件</li></ol><p><img src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img/img/image-20220522145424006.png" alt="image-20220522145424006"></p><ol start="5"><li>安装成功！</li></ol><p><img src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img/img/image-20220522145523338.png" alt="image-20220522145523338"></p><h2 id="三、Visual-Studio-Comunity-2017的安装"><a href="#三、Visual-Studio-Comunity-2017的安装" class="headerlink" title="三、Visual Studio Comunity 2017的安装"></a>三、Visual Studio Comunity 2017的安装</h2><ol><li><p>下载Visual Studio Comunity 2017，下载链接：<a href="https://developer.microsoft.com/zh-cn/windows/downloads">https://developer.microsoft.com/zh-cn/windows/downloads</a></p><ul><li>安装VS2017，这里我们只需要勾选<strong>黑色圆圈</strong>中的框框就可以了，其它地方保持默认，然后等待<strong>安装完成</strong>就可以了，安装完成之后一定要记得<strong>登录账号</strong>。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img/img/image-20220522145911160.png" alt="image-20220522145911160"></p></li><li><p>下载windows10 SDK，下载链接：<a href="https://download.microsoft.com/download/4/2/2/42245968-6A79-4DA7-A5FB-08C0AD0AE661/windowssdk/winsdksetup.exe">https://download.microsoft.com/download/4/2/2/42245968-6A79-4DA7-A5FB-08C0AD0AE661/windowssdk/winsdksetup.exe</a></p></li></ol><ul><li>下载后运行，默认选项即可，选择“Next”</li></ul><p><img src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img/img/image-20220522150228904.png" alt="image-20220522150228904"></p><ul><li>默认，选择“Next”</li></ul><p><img src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img/img/image-20220522150254150.png" alt="image-20220522150254150"></p><ul><li>默认，选择“Accept”</li></ul><p><img src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img@master/202205221622494.png" alt="image-20220522150321287"></p><ul><li>只需要选择“Debugging Toolsfor Windows”，点击“Install”（需要联网下载）。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img/img/image-20220522150345875.png" alt="image-20220522150345875"></p><ul><li>安装完成</li></ul><p><img src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img@master/202205221610167.png" alt="image-20220522150405448"></p><h2 id="四、Qt-MSVC2017"><a href="#四、Qt-MSVC2017" class="headerlink" title="四、Qt+MSVC2017"></a>四、Qt+MSVC2017</h2><p>​    现在打开Qt应该就能直接使用编译环境了，当然你也可以手动调节Kits：</p><ol><li>检查编译器是否正常</li></ol><p><img src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img/img/image-20220522150551227.png" alt="image-20220522150551227"></p><ol start="2"><li>同时在“Kits”-&gt;“Debuggers”下，也自动检测到调试器了。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img/img/image-20220522150614158.png" alt="image-20220522150614158"></p><ol start="3"><li><p>然后我们选择“Kits”-&gt;“构建套件”，然后选择“Desktop Qt 5.13.0 MSVC2017 64bit”，</p><p>配置C/C++编译器均为：“Microsoft Visual C++ Compiler 15.0（x86_amd64）”；</p><p>配置调试器为：“Auto-detected CDB at D:\Windows Kits\10\Debuggers\x64\cdb.exe”。</p><p>然后选择“Apply”，然后“OK”。<br><img src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img@master/202205221622513.png" alt="image-20220522150640659"></p></li><li><p>建个测试工程，打个断点，F5调试，断点停住，好了，环境搭建成功。</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img/img/image-20220522150704463.png" alt="image-20220522150704463"></p><h2 id="五、一些问题的总结"><a href="#五、一些问题的总结" class="headerlink" title="五、一些问题的总结"></a>五、一些问题的总结</h2><ol><li>jom(版本号)- empower your cores错误</li></ol><p>该错误目前没有寻求到更好的解决办法，采用了Qt Creator中选择构建和运行——概要</p><p><img src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img/img/image-20220522150810388.png" alt="image-20220522150810388"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编入门</title>
      <link href="/2022/04/18/%E6%B1%87%E7%BC%96%E5%85%A5%E9%97%A8/"/>
      <url>/2022/04/18/%E6%B1%87%E7%BC%96%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="汇编入门"><a href="#汇编入门" class="headerlink" title="汇编入门"></a>汇编入门</h1><p>本文来自于：<a href="https://baijiahao.baidu.com/s?id=1701777173069223091&wfr=spider&for=pc">干货｜汇编语言入门教程 (baidu.com)</a></p><h2 id="一-、来历"><a href="#一-、来历" class="headerlink" title="一 、来历"></a>一 、来历</h2><p>每种CPIU的机器指令都是不一样的，因此对应的汇编语言也不一样。本文介绍的是目前最常见的x86汇编语言，即Intel公司的CPU使用的那一种。</p><h2 id="二、寄存器"><a href="#二、寄存器" class="headerlink" title="二、寄存器"></a>二、寄存器</h2><p>学习汇编语言，首先必须了解两个知识点：<strong>寄存器</strong>和<strong>内存模型</strong>。</p><p>先来看寄存器。CPU 本身只负责运算，不负责储存数据。数据一般都储存在内存之中，CPU 要用的时候就去内存读写数据。</p><p>但是，CPU 的运算速度远高于内存的读写速度，为了避免被拖慢，CPU 都自带一级缓存和二级缓存。基本上，CPU 缓存可以看作是读写速度较快的内存。</p><p>但是，CPU 缓存还是不够快，另外数据在缓存里面的地址是不固定的，CPU 每次读写都要寻址也会拖慢速度。</p><p>因此，<strong>除了缓存之外，CPU 还自带了寄存器（register），用来储存最常用的数据。</strong>也就是说，那些最频繁读写的数据（比如循环变量），都会放在寄存器里面，CPU 优先读写寄存器，再由寄存器跟内存交换数据。</p><p><img src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img/202204182027274.png" alt="image-20220418145232756"></p><h2 id="三、寄存器的种类"><a href="#三、寄存器的种类" class="headerlink" title="三、寄存器的种类"></a>三、寄存器的种类</h2><p>早期的 x86 CPU 只有8个寄存器，而且每个都有不同的用途。现在的寄存器已经有100多个了，都变成通用寄存器，不特别指定用途了，但是早期寄存器的名字都被保存了下来。</p><ul><li>EAX</li><li>EBX</li><li>ECX</li><li>EDX</li><li>EDI</li><li>ESI</li><li>EBP</li><li>ESP</li></ul><p>上面这8个寄存器之中，前面七个都是通用的。<strong>ESP 寄存器有特定用途，保存当前 Stack 的地址</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img/202204181456241.png" alt="image-20220418145659197"></p><p>我们常常看到 32位 CPU、64位 CPU 这样的名称，其实指的就是寄存器的大小。32 位 CPU 的寄存器大小就是4个字节。</p><h2 id="四、内存模型"><a href="#四、内存模型" class="headerlink" title="四、内存模型"></a>四、内存模型</h2><h3 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h3><p>寄存器只能存放很少量的数据，大多数时候，CPU 要指挥寄存器，直接跟内存交换数据。所以，除了寄存器，还必须了解<strong>内存怎么储存数据</strong>。</p><p>程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从0x1000到0x8000，起始地址是较小的那个地址，结束地址是较大的那个地址。</p><p><img src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img/202204181500013.png" alt="image-20220418150000977"></p><p>程序运行过程中，对于<strong>动态的</strong>内存占用请求（比如新建对象，或者使用malloc命令），系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是从起始地址开始划分（实际上，起始地址会有一段静态数据，这里忽略）。</p><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p>除了 Heap 以外，其他的内存占用叫做 <strong>Stack（栈）</strong>。简单说，Stack 是由于函数运行而<strong>临时</strong>占用的内存区域。</p><p><img src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img/202204181504143.png" alt="image-20220418150446100"></p><p>请看下面的例子。</p><p>int main() { int a = 2; int b = 3;}上面代码中，系统开始执行main函数时，会为它在内存里面建立一个<strong>帧（frame）</strong>，所有main的内部变量（比如a和b）都保存在这个帧里面。main函数执行结束后，该帧就会被回收，释放所有的内部变量，不再占用空间。</p><p><strong>mian</strong>函数在Stack区中建立。</p><p><img src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img/202204182027493.png" alt="image-20220418150548788"></p><p>如果函数内部调用了其他函数，会发生什么情况？</p><p>int main() { int a = 2; int b = 3; return add_a_and_b(a, b);}上面代码中，main函数内部调用了add_a_and_b函数。执行到这一行的时候，系统也会为add_a_and_b新建一个帧，用来储存它的内部变量。也就是说，此时同时存在两个帧：main和add_a_and_b。<strong>一般来说，调用栈有多少层，就有多少帧。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img/202204182027802.png" alt="image-20220418150903520"></p><p>等到add_a_and_b运行结束，它的帧就会被回收，系统会回到函数main刚才中断执行的地方，继续往下执行。通过这种机制，就实现了函数的层层调用，并且每一层都能使用自己的本地变量。</p><p>所有的帧都存放在 Stack，由于帧是一层层叠加的，所以 Stack 叫做栈。生成新的帧，叫做”入栈”，英文是 push；栈的回收叫做”出栈”，英文是 pop。Stack 的特点就是，最晚入栈的帧最早出栈（因为最内层的函数调用，最先结束运行），这就叫做**”后进先出”**的数据结构。</p><p>每一次函数执行结束，就自动释放一个帧，所有函数执行结束，整个 Stack 就都释放了。</p><p><img src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img/202204181510309.png" alt="image-20220418151027247"></p><p>Stack 是由内存区域的结束地址开始，从高位（地址）向低位（地址）分配。比如，内存区域的结束地址是0x8000，第一帧假定是16字节，那么下一次分配的地址就会从0x7FF0开始；第二帧假定需要64字节，那么地址就会移动到0x7FB0。</p><p><img src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img/202204181512878.png" alt="image-20220418151219842"></p><h2 id="五、CPU指令"><a href="#五、CPU指令" class="headerlink" title="五、CPU指令"></a>五、CPU指令</h2><h3 id="1、一个实例"><a href="#1、一个实例" class="headerlink" title="1、一个实例"></a>1、一个实例</h3><p>了解寄存器和内存模型以后，就可以来看汇编语言到底是什么了。下面是一个简单的程序<code>example.c</code>。</p><pre><code class="c">int add_a_and_b(int a, int b) &#123;   return a + b;&#125;int main() &#123;   return add_a_and_b(2, 3);&#125;</code></pre><p>gcc 将这个程序转成汇编语言。</p><pre><code>$ gcc -S example.c</code></pre><p>上面的命令执行以后，会生成一个文本文件<code>example.s</code>，里面就是汇编语言，包含了几十行指令。这么说吧，一个高级语言的简单操作，底层可能由几个，甚至几十个 CPU 指令构成。CPU 依次执行这些指令，完成这一步操作。</p><p><code>example.s</code>经过简化以后，大概是下面的样子。</p><pre><code class="assembly">_add_a_and_b:   push   %ebx   mov    %eax, [%esp+8]    mov    %ebx, [%esp+12]   add    %eax, %ebx    pop    %ebx    ret  _main:   push   3   push   2   call   _add_a_and_b    add    %esp, 8   ret</code></pre><p>可以看到，原程序的两个函数<code>add_a_and_b</code>和<code>main</code>，对应两个标签<code>_add_a_and_b</code>和<code>_main</code>。每个标签里面是该函数所转成的 CPU 运行流程。</p><p>每一行就是 CPU 执行的一次操作。它又分成两部分，就以其中一行为例。</p><pre><code class="assembly">push   %ebx</code></pre><p>这一行里面，<code>push</code>是 CPU 指令，<code>%ebx</code>是该指令要用到的运算子。一个 CPU 指令可以有零个到多个运算子。</p><h3 id="2、push指令"><a href="#2、push指令" class="headerlink" title="2、push指令"></a>2、push指令</h3><p>根据约定，程序从<code>_main</code>标签开始执行，这时会在 Stack 上为<code>main</code>建立一个帧，并将 Stack 所指向的地址，写入 ESP 寄存器。后面如果有数据要写入<code>main</code>这个帧，就会写在 ESP 寄存器所保存的地址。</p><p>然后，开始执行第一行代码。</p><pre><code class="assembly">push   3</code></pre><p><code>push</code>指令用于将运算子放入 Stack，这里就是将<code>3</code>写入<code>main</code>这个帧。</p><p>虽然看上去很简单，<code>push</code>指令其实有一个前置操作。它会先取出 ESP 寄存器里面的地址，将其减去4个字节，然后将新地址写入 ESP 寄存器。使用减法是因为 Stack 从高位向低位发展，4个字节则是因为<code>3</code>的类型是<code>int</code>，占用4个字节。得到新地址以后， 3 就会写入这个地址开始的四个字节。</p><pre><code class="assembly">push   2</code></pre><p>第二行也是一样，<code>push</code>指令将<code>2</code>写入<code>main</code>这个帧，位置紧贴着前面写入的<code>3</code>。这时，ESP 寄存器会再减去 4个字节（累计减去8）。</p><p><img src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img/202204182021327.png" alt="image-20220418202124270"></p><h3 id="3、call指令"><a href="#3、call指令" class="headerlink" title="3、call指令"></a>3、call指令</h3><p>第三行的<code>call</code>指令用来调用函数。</p><pre><code class="assembly">call   _add_a_and_b</code></pre><p>上面的代码表示调用<code>add_a_and_b</code>函数。这时，程序就会去找<code>_add_a_and_b</code>标签，并为该函数建立一个新的帧。</p><p>下面就开始执行<code>_add_a_and_b</code>的代码。</p><pre><code class="assembly">push   %ebx</code></pre><p>这一行表示将 EBX 寄存器里面的值，写入<code>_add_a_and_b</code>这个帧。这是因为后面要用到这个寄存器，就先把里面的值取出来，用完后再写回去。</p><p>这时，<code>push</code>指令会再将 ESP 寄存器里面的地址减去4个字节（累计减去12）。</p><h3 id="4、mov指令"><a href="#4、mov指令" class="headerlink" title="4、mov指令"></a>4、mov指令</h3><p><code>mov</code>指令用于将一个值写入某个寄存器。</p><pre><code class="assembly">mov    %eax, [%esp+8] </code></pre><p>这一行代码表示，先将 ESP 寄存器里面的地址加上8个字节，得到一个新的地址，然后按照这个地址在 Stack 取出数据。根据前面的步骤，可以推算出这里取出的是<code>2</code>，再将<code>2</code>写入 EAX 寄存器。</p><p>下一行代码也是干同样的事情。</p><pre><code class="assembly">mov    %ebx, [%esp+12] </code></pre><p>上面的代码将 ESP 寄存器的值加12个字节，再按照这个地址在 Stack 取出数据，这次取出的是<code>3</code>，将其写入 EBX 寄存器。</p><h3 id="5、add指令"><a href="#5、add指令" class="headerlink" title="5、add指令"></a>5、add指令</h3><p><code>add</code>指令用于将两个运算子相加，并将结果写入第一个运算子。</p><pre><code class="assembly">add    %eax, %ebx</code></pre><p>上面的代码将 EAX 寄存器的值（即2）加上 EBX 寄存器的值（即3），得到结果5，再将这个结果写入第一个运算子 EAX 寄存器。</p><h3 id="6、pop指令"><a href="#6、pop指令" class="headerlink" title="6、pop指令"></a>6、pop指令</h3><p><code>pop</code>指令用于取出 Stack 最近一个写入的值（即最低位地址的值），并将这个值写入运算子指定的位置。</p><pre><code class="assembly">pop    %ebx</code></pre><p>上面的代码表示，取出 Stack 最近写入的值（即 EBX 寄存器的原始值），再将这个值写回 EBX 寄存器（因为加法已经做完了，EBX 寄存器用不到了）。</p><p>注意，<code>pop</code>指令还会将 ESP 寄存器里面的地址加4，即回收4个字节。</p><h3 id="7、ret指令"><a href="#7、ret指令" class="headerlink" title="7、ret指令"></a>7、ret指令</h3><p><code>ret</code>指令用于终止当前函数的执行，将运行权交还给上层函数。也就是，当前函数的帧将被回收。</p><pre><code class="assembly">ret</code></pre><p>可以看到，该指令没有运算子。</p><p>随着<code>add_a_and_b</code>函数终止执行，系统就回到刚才<code>main</code>函数中断的地方，继续往下执行。</p><pre><code class="assembly">add    %esp, 8 </code></pre><p>上面的代码表示，将 ESP 寄存器里面的地址，手动加上8个字节，再写回 ESP 寄存器。这是因为 ESP 寄存器的是 Stack 的写入开始地址，前面的<code>pop</code>操作已经回收了4个字节，这里再回收8个字节，等于全部回收。</p><pre><code class="assembly">ret</code></pre><p>最后，<code>main</code>函数运行结束，<code>ret</code>指令退出程序执行。</p>]]></content>
      
      
      <categories>
          
          <category> 汇编语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式——单例模式</title>
      <link href="/2022/03/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/03/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式——单例模式"><a href="#设计模式——单例模式" class="headerlink" title="设计模式——单例模式"></a>设计模式——单例模式</h1><h2 id="一、单例模式实现要点"><a href="#一、单例模式实现要点" class="headerlink" title="一、单例模式实现要点"></a>一、单例模式实现要点</h2><ul><li>私有构造函数</li><li>静态私有成员变量</li><li>静态共有的工厂方法</li></ul><h3 id="核心实现代码"><a href="#核心实现代码" class="headerlink" title="核心实现代码"></a>核心实现代码</h3><pre><code class="java">public class Singleton &#123;    private static Singleton instance=null;  //静态私有成员变量       //私有构造函数    private Singleton() &#123;        &#125;       //静态公有工厂方法，返回唯一实例    public static Singleton getInstance() &#123;        if(instance==null)            instance=new Singleton();            return instance;    &#125;&#125;</code></pre><h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><ul><li>单例类只能有一个实例；</li><li>单例类必须自己创建自己的唯一实例；</li><li>单例类必须给所有其它对象提供这一实例。</li></ul><p><strong>ps：</strong>在单例类中通过静态变量保存一个实例，使用的时候实际上是用的这个实例。让构造函数为private，这样该类就不会被实例化，只有自己能实例化自己。</p><h2 id="二、单例模式的几种实现方式"><a href="#二、单例模式的几种实现方式" class="headerlink" title="二、单例模式的几种实现方式"></a>二、单例模式的几种实现方式</h2><h3 id="1、懒汉式，线程不安全"><a href="#1、懒汉式，线程不安全" class="headerlink" title="1、懒汉式，线程不安全"></a>1、懒汉式，线程不安全</h3><p><strong>是否Lazy初始化：</strong>是</p><p><strong>是否多线程安全：</strong>否</p><p><strong>实现难度：</strong>易</p><p><strong>描述：</strong>这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。</p><p>这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。</p><p><strong>实例：</strong></p><pre><code class="java">public class Singleton &#123;      private static Singleton instance;      private Singleton ()&#123;&#125;        public static Singleton getInstance() &#123;          if (instance == null) &#123;              instance = new Singleton();          &#125;          return instance;      &#125;  &#125;</code></pre><p>下面几种都支持多线程，但是性能上有所差异。</p><h3 id="2、懒汉式，线程安全"><a href="#2、懒汉式，线程安全" class="headerlink" title="2、懒汉式，线程安全"></a>2、懒汉式，线程安全</h3><p><strong>是否Lazy初始化：</strong>是</p><p><strong>是否多线程安全：</strong>是</p><p><strong>实现难度：</strong>易</p><p><strong>描述：</strong>这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。</p><p>优点：第一次调用才初始化，避免内存浪费。<br>缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。<br>getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。</p><pre><code class="java">public class Singleton &#123;      private static Singleton instance;      private Singleton ()&#123;&#125;      public static synchronized Singleton getInstance() &#123;          if (instance == null) &#123;              instance = new Singleton();          &#125;          return instance;      &#125;  &#125;</code></pre><h3 id="3、饿汉式"><a href="#3、饿汉式" class="headerlink" title="3、饿汉式"></a>3、饿汉式</h3><p><strong>是否Lazy初始化：</strong>否</p><p><strong>是否多线程安全：</strong>是</p><p><strong>实现难度：</strong>易</p><p><strong>描述：</strong>这种方式比较常用，但容易产生垃圾对象。</p><p>优点：没有加锁，执行效率会提高。<br>缺点：类加载时就初始化，浪费内存。<br>它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。    </p><p><strong>实现：</strong></p><pre><code class="java">public class Singleton &#123;      private static Singleton instance = new Singleton(); //类装载时就实例化，浪费内存     private Singleton ()&#123;&#125;      public static Singleton getInstance() &#123;      return instance;      &#125;  &#125;</code></pre><h3 id="4、双检锁-双重校验锁（DCL，即-double-checked-locking）"><a href="#4、双检锁-双重校验锁（DCL，即-double-checked-locking）" class="headerlink" title="4、双检锁/双重校验锁（DCL，即 double-checked locking）"></a>4、双检锁/双重校验锁（DCL，即 double-checked locking）</h3><p><strong>是否Lazy初始化：</strong>是</p><p><strong>是否多线程安全：</strong>是</p><p><strong>实现难度：</strong>较复杂</p><p><strong>描述：</strong>这种方式采用双锁机制，安全且在多线程情况下能保持高性能。<br>getInstance() 的性能对应用程序很关键。</p><p><strong>实例：</strong></p><pre><code class="java">public class Singleton &#123;      private volatile static Singleton singleton;      private Singleton ()&#123;&#125;      public static Singleton getSingleton() &#123;      if (singleton == null) &#123;          synchronized (Singleton.class) &#123;              if (singleton == null) &#123;                  singleton = new Singleton();              &#125;          &#125;      &#125;      return singleton;      &#125;  &#125;</code></pre><h3 id="5、登记式-静态内部类"><a href="#5、登记式-静态内部类" class="headerlink" title="5、登记式/静态内部类"></a>5、登记式/静态内部类</h3><p><strong>是否Lazy初始化：</strong>是</p><p><strong>是否多线程安全：</strong>是</p><p><strong>实现难度：</strong>一般</p><p><strong>描述：</strong>这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。<br>这种方式同样利用了 classloader 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。</p><p><strong>实现：</strong></p><pre><code class="java">public class Singleton &#123;      private static class SingletonHolder &#123;      private static final Singleton INSTANCE = new Singleton();      &#125;      private Singleton ()&#123;&#125;      public static final Singleton getInstance() &#123;          return SingletonHolder.INSTANCE;      &#125;  &#125;</code></pre><h3 id="6、枚举"><a href="#6、枚举" class="headerlink" title="6、枚举"></a>6、枚举</h3><p><strong>是否Lazy初始化：</strong>否</p><p><strong>是否多线程安全：</strong>是</p><p><strong>实现难度：</strong>易</p><p><strong>描述：</strong>这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。<br>这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。<br>不能通过 reflection attack 来调用私有构造方法。</p><p><strong>经验之谈：</strong>一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式——工厂模式</title>
      <link href="/2022/03/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/03/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式——工厂模式"><a href="#设计模式——工厂模式" class="headerlink" title="设计模式——工厂模式"></a>设计模式——工厂模式</h1><h2 id="一、简单工厂模式"><a href="#一、简单工厂模式" class="headerlink" title="一、简单工厂模式"></a>一、简单工厂模式</h2><p>定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。</p><p><img src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img/202203301851810.png" alt="image-20220320212000528"></p><p><strong>ps：</strong>传入一个正确的参数，就可以获取所需要的对象，而无需知道其创建细节。</p><p><img src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img/202203301852902.png" alt="image-20220320213104968"></p><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><ol><li>抽象产品类，整合了各个产品的共同元素：</li></ol><pre><code class="java">public abstract class Product&#123;    //所有产品类的公共业务方法    public void methodSame()&#123;        // 公共方法的实现    &#125;    // 声明抽象业务方法    public abstract void methodDiff();&#125;</code></pre><ol start="2"><li>具体产品类，某个具体产品类的实现：</li></ol><pre><code class="java">// 继承抽象产品类，从中获得产品类的共同元素public class ConcreteProduct extends Product&#123;    // 业务方法的实现&#125;</code></pre><ol start="3"><li>工厂类：</li></ol><pre><code class="java">public class Factory&#123;    // 静态工厂方法    public static Product getProduct(String arg)&#123;        Product product = null;        if(arg.equalslgnoreCase(&quot;A&quot;))&#123;            product = new ConcreteProductA();            // 初始化设置product        &#125;        else if(arg.aqualslgnoreCase(&quot;B&quot;))&#123;            product = new ConcreteProductB();            // 初始化设置product        &#125;        return product    &#125;&#125;</code></pre><ol start="4"><li>客户端：</li></ol><pre><code class="java">public static Client&#123;    public static void main(String args[])&#123;        Product product;        // 通过工厂类创建产品对象        product = Factory.getProduct(&quot;A&quot;);        product.methodSame();        product.methodDiff();    &#125;&#125;</code></pre><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>客户端读入参数，将参数传给工厂，工厂找到参数对应的产品子类，工厂实例化产品父类，再将父类动态绑定到子类实例化的对象上。</p><h2 id="二、工厂方法模式"><a href="#二、工厂方法模式" class="headerlink" title="二、工厂方法模式"></a>二、工厂方法模式</h2><p>定义一个用于创建对象的接口，但是让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。</p><p><img src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img/202203301851819.png" alt="image-20220321151754808"></p><p><img src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img/202203301851824.png" alt="image-20220321161159238"></p><h3 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h3><ol><li>抽象工厂类</li></ol><pre><code class="java">public interface Factory&#123;    public Product factoryMethod();&#125;</code></pre><ol start="2"><li>具体工厂类</li></ol><pre><code class="java">public class ConcreteFactory implements Factory&#123;    public Product factoryMethod()&#123;        return new ConcreteProduct();    &#125;&#125;</code></pre><ol start="3"><li>客户端</li></ol><pre><code class="java">......Factory factory;factory = new ConcreteFactory();Product product;product = factory.factoryMethod();......</code></pre><p><strong>ps：</strong>工厂方法模式和简单工厂模式的区别在于，一个是对产品的共同之处进行了抽象，一个是对产品和工厂的共同之处进行了抽象。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
