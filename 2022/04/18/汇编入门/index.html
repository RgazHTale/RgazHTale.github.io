


<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>  汇编入门 |    JIANG Tao&#39;blog.</title>
  <meta name="description" content="蒋涛的计算机学习博客.">
  <!-- 标签页图标 -->
  
  <link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img/202203311342444.jpg" type="image/x-icon">
  

  <!-- 图标库 -->
  <link href="https://cdn.jsdelivr.net/npm/remixicon@2.2.0/fonts/remixicon.css" rel="stylesheet">
  <!-- 动画库 -->
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fushaolei/cdn-white@1.0/css/animate.css"/>
  
  <!-- css文件 -->
  
<link rel="stylesheet" href="/css/white.css">

  <!-- 代码高亮 -->
  
    
      
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.1.1/styles/github.css">

    
  
<meta name="generator" content="Hexo 5.4.1"></head>


<body>

<div class="menu-outer">
    <div class="menu-inner">
      <div class="menu-site-name  animate__animated  animate__fadeInUp">
        <a href="/">
          JIANG Tao&#39;blog.
        </a>
        
      </div>
      <div class="menu-group">
        <ul class="menu-ul">
        
          <a href="/" class="nav-link">
            <li class="menu-li  animate__animated  animate__fadeInUp">
              HOME
            </li>
          </a>
        
          <a href="/archives" class="nav-link">
            <li class="menu-li  animate__animated  animate__fadeInUp">
              BLOG
            </li>
          </a>
        
        
          <li class="menu-li animate__animated  animate__fadeInUp" id="sort">
             文章分类
             <div class="categories-outer " id="sort-div">
               <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/">汇编语言</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li></ul>
             </div>
          </li>
        
        
          <li class="menu-li animate__animated  animate__fadeInUp" id="mobile-menu">
            <i class="ri-menu-line"></i>
          </li>
        
        </ul>

      </div>

    </div>
</div>
<div id="mobile-main" class="animate__animated  animate__fadeIn">
  <div class="mobile-menu-inner">
    <div class="mobile-menu-site-name animate__animated  animate__fadeInUp">
      <a href="/">
        JIANG Tao&#39;blog.
      </a>
    </div>
    <div class="mobile-menu-group" id="mobile-close">
      <i class="ri-close-line"></i>
    </div>

  </div>

  <div class="mobile-menu-div">
  
    <a href="/" class="mobile-nav-link">
      <div class="mobile-menu-child animate__animated  animate__fadeInUp">
        <span>HOME</span>
      </div>
    </a>
  
    <a href="/archives" class="mobile-nav-link">
      <div class="mobile-menu-child animate__animated  animate__fadeInUp">
        <span>BLOG</span>
      </div>
    </a>
  
  
  </div>


</div>

<div class="body-outer">
  <div class="body-inner">
    
<article class="post-inner">
  <div class="post-content-outer">
    <div class="post-intro">
      <div class="post-title animate__animated  animate__fadeInUp">汇编入门</div>
      <div class="meta-intro animate__animated  animate__fadeInUp">Apr 18 2022</div>
      
    </div>
    <div class="post-content-inner">
      <div class="post-content-inner-space">

      </div>
      <div class="post-content-main animate__animated  animate__fadeInUp">
        <!-- top型目录 -->
        
        <h1 id="汇编入门"><a href="#汇编入门" class="headerlink" title="汇编入门"></a>汇编入门</h1><p>本文来自于：<a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1701777173069223091&wfr=spider&for=pc">干货｜汇编语言入门教程 (baidu.com)</a></p>
<h2 id="一-、来历"><a href="#一-、来历" class="headerlink" title="一 、来历"></a>一 、来历</h2><p>每种CPIU的机器指令都是不一样的，因此对应的汇编语言也不一样。本文介绍的是目前最常见的x86汇编语言，即Intel公司的CPU使用的那一种。</p>
<h2 id="二、寄存器"><a href="#二、寄存器" class="headerlink" title="二、寄存器"></a>二、寄存器</h2><p>学习汇编语言，首先必须了解两个知识点：<strong>寄存器</strong>和<strong>内存模型</strong>。</p>
<p>先来看寄存器。CPU 本身只负责运算，不负责储存数据。数据一般都储存在内存之中，CPU 要用的时候就去内存读写数据。</p>
<p>但是，CPU 的运算速度远高于内存的读写速度，为了避免被拖慢，CPU 都自带一级缓存和二级缓存。基本上，CPU 缓存可以看作是读写速度较快的内存。</p>
<p>但是，CPU 缓存还是不够快，另外数据在缓存里面的地址是不固定的，CPU 每次读写都要寻址也会拖慢速度。</p>
<p>因此，<strong>除了缓存之外，CPU 还自带了寄存器（register），用来储存最常用的数据。</strong>也就是说，那些最频繁读写的数据（比如循环变量），都会放在寄存器里面，CPU 优先读写寄存器，再由寄存器跟内存交换数据。</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img/202204182027274.png" >
        </sapn>
      </p>
<h2 id="三、寄存器的种类"><a href="#三、寄存器的种类" class="headerlink" title="三、寄存器的种类"></a>三、寄存器的种类</h2><p>早期的 x86 CPU 只有8个寄存器，而且每个都有不同的用途。现在的寄存器已经有100多个了，都变成通用寄存器，不特别指定用途了，但是早期寄存器的名字都被保存了下来。</p>
<ul>
<li>EAX</li>
<li>EBX</li>
<li>ECX</li>
<li>EDX</li>
<li>EDI</li>
<li>ESI</li>
<li>EBP</li>
<li>ESP</li>
</ul>
<p>上面这8个寄存器之中，前面七个都是通用的。<strong>ESP 寄存器有特定用途，保存当前 Stack 的地址</strong>。</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img/202204181456241.png" >
        </sapn>
      </p>
<p>我们常常看到 32位 CPU、64位 CPU 这样的名称，其实指的就是寄存器的大小。32 位 CPU 的寄存器大小就是4个字节。</p>
<h2 id="四、内存模型"><a href="#四、内存模型" class="headerlink" title="四、内存模型"></a>四、内存模型</h2><h3 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h3><p>寄存器只能存放很少量的数据，大多数时候，CPU 要指挥寄存器，直接跟内存交换数据。所以，除了寄存器，还必须了解<strong>内存怎么储存数据</strong>。</p>
<p>程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从0x1000到0x8000，起始地址是较小的那个地址，结束地址是较大的那个地址。</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img/202204181500013.png" >
        </sapn>
      </p>
<p>程序运行过程中，对于<strong>动态的</strong>内存占用请求（比如新建对象，或者使用malloc命令），系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是从起始地址开始划分（实际上，起始地址会有一段静态数据，这里忽略）。</p>
<h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p>除了 Heap 以外，其他的内存占用叫做 <strong>Stack（栈）</strong>。简单说，Stack 是由于函数运行而<strong>临时</strong>占用的内存区域。</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img/202204181504143.png" >
        </sapn>
      </p>
<p>请看下面的例子。</p>
<p>int main() { int a = 2; int b = 3;}上面代码中，系统开始执行main函数时，会为它在内存里面建立一个<strong>帧（frame）</strong>，所有main的内部变量（比如a和b）都保存在这个帧里面。main函数执行结束后，该帧就会被回收，释放所有的内部变量，不再占用空间。</p>
<p><strong>mian</strong>函数在Stack区中建立。</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img/202204182027493.png" >
        </sapn>
      </p>
<p>如果函数内部调用了其他函数，会发生什么情况？</p>
<p>int main() { int a = 2; int b = 3; return add_a_and_b(a, b);}上面代码中，main函数内部调用了add_a_and_b函数。执行到这一行的时候，系统也会为add_a_and_b新建一个帧，用来储存它的内部变量。也就是说，此时同时存在两个帧：main和add_a_and_b。<strong>一般来说，调用栈有多少层，就有多少帧。</strong></p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img/202204182027802.png" >
        </sapn>
      </p>
<p>等到add_a_and_b运行结束，它的帧就会被回收，系统会回到函数main刚才中断执行的地方，继续往下执行。通过这种机制，就实现了函数的层层调用，并且每一层都能使用自己的本地变量。</p>
<p>所有的帧都存放在 Stack，由于帧是一层层叠加的，所以 Stack 叫做栈。生成新的帧，叫做”入栈”，英文是 push；栈的回收叫做”出栈”，英文是 pop。Stack 的特点就是，最晚入栈的帧最早出栈（因为最内层的函数调用，最先结束运行），这就叫做**”后进先出”**的数据结构。</p>
<p>每一次函数执行结束，就自动释放一个帧，所有函数执行结束，整个 Stack 就都释放了。</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img/202204181510309.png" >
        </sapn>
      </p>
<p>Stack 是由内存区域的结束地址开始，从高位（地址）向低位（地址）分配。比如，内存区域的结束地址是0x8000，第一帧假定是16字节，那么下一次分配的地址就会从0x7FF0开始；第二帧假定需要64字节，那么地址就会移动到0x7FB0。</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img/202204181512878.png" >
        </sapn>
      </p>
<h2 id="五、CPU指令"><a href="#五、CPU指令" class="headerlink" title="五、CPU指令"></a>五、CPU指令</h2><h3 id="1、一个实例"><a href="#1、一个实例" class="headerlink" title="1、一个实例"></a>1、一个实例</h3><p>了解寄存器和内存模型以后，就可以来看汇编语言到底是什么了。下面是一个简单的程序<code>example.c</code>。</p>
<pre><code class="c">int add_a_and_b(int a, int b) &#123;
   return a + b;
&#125;

int main() &#123;
   return add_a_and_b(2, 3);
&#125;
</code></pre>
<p>gcc 将这个程序转成汇编语言。</p>
<pre><code>$ gcc -S example.c
</code></pre>
<p>上面的命令执行以后，会生成一个文本文件<code>example.s</code>，里面就是汇编语言，包含了几十行指令。这么说吧，一个高级语言的简单操作，底层可能由几个，甚至几十个 CPU 指令构成。CPU 依次执行这些指令，完成这一步操作。</p>
<p><code>example.s</code>经过简化以后，大概是下面的样子。</p>
<pre><code class="assembly">_add_a_and_b:
   push   %ebx
   mov    %eax, [%esp+8] 
   mov    %ebx, [%esp+12]
   add    %eax, %ebx 
   pop    %ebx 
   ret  

_main:
   push   3
   push   2
   call   _add_a_and_b 
   add    %esp, 8
   ret
</code></pre>
<p>可以看到，原程序的两个函数<code>add_a_and_b</code>和<code>main</code>，对应两个标签<code>_add_a_and_b</code>和<code>_main</code>。每个标签里面是该函数所转成的 CPU 运行流程。</p>
<p>每一行就是 CPU 执行的一次操作。它又分成两部分，就以其中一行为例。</p>
<pre><code class="assembly">push   %ebx
</code></pre>
<p>这一行里面，<code>push</code>是 CPU 指令，<code>%ebx</code>是该指令要用到的运算子。一个 CPU 指令可以有零个到多个运算子。</p>
<h3 id="2、push指令"><a href="#2、push指令" class="headerlink" title="2、push指令"></a>2、push指令</h3><p>根据约定，程序从<code>_main</code>标签开始执行，这时会在 Stack 上为<code>main</code>建立一个帧，并将 Stack 所指向的地址，写入 ESP 寄存器。后面如果有数据要写入<code>main</code>这个帧，就会写在 ESP 寄存器所保存的地址。</p>
<p>然后，开始执行第一行代码。</p>
<pre><code class="assembly">push   3
</code></pre>
<p><code>push</code>指令用于将运算子放入 Stack，这里就是将<code>3</code>写入<code>main</code>这个帧。</p>
<p>虽然看上去很简单，<code>push</code>指令其实有一个前置操作。它会先取出 ESP 寄存器里面的地址，将其减去4个字节，然后将新地址写入 ESP 寄存器。使用减法是因为 Stack 从高位向低位发展，4个字节则是因为<code>3</code>的类型是<code>int</code>，占用4个字节。得到新地址以后， 3 就会写入这个地址开始的四个字节。</p>
<pre><code class="assembly">push   2
</code></pre>
<p>第二行也是一样，<code>push</code>指令将<code>2</code>写入<code>main</code>这个帧，位置紧贴着前面写入的<code>3</code>。这时，ESP 寄存器会再减去 4个字节（累计减去8）。</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="https://cdn.jsdelivr.net/gh/RgazHTale/blog-img/202204182021327.png" >
        </sapn>
      </p>
<h3 id="3、call指令"><a href="#3、call指令" class="headerlink" title="3、call指令"></a>3、call指令</h3><p>第三行的<code>call</code>指令用来调用函数。</p>
<pre><code class="assembly">call   _add_a_and_b
</code></pre>
<p>上面的代码表示调用<code>add_a_and_b</code>函数。这时，程序就会去找<code>_add_a_and_b</code>标签，并为该函数建立一个新的帧。</p>
<p>下面就开始执行<code>_add_a_and_b</code>的代码。</p>
<pre><code class="assembly">push   %ebx
</code></pre>
<p>这一行表示将 EBX 寄存器里面的值，写入<code>_add_a_and_b</code>这个帧。这是因为后面要用到这个寄存器，就先把里面的值取出来，用完后再写回去。</p>
<p>这时，<code>push</code>指令会再将 ESP 寄存器里面的地址减去4个字节（累计减去12）。</p>
<h3 id="4、mov指令"><a href="#4、mov指令" class="headerlink" title="4、mov指令"></a>4、mov指令</h3><p><code>mov</code>指令用于将一个值写入某个寄存器。</p>
<pre><code class="assembly">mov    %eax, [%esp+8] 
</code></pre>
<p>这一行代码表示，先将 ESP 寄存器里面的地址加上8个字节，得到一个新的地址，然后按照这个地址在 Stack 取出数据。根据前面的步骤，可以推算出这里取出的是<code>2</code>，再将<code>2</code>写入 EAX 寄存器。</p>
<p>下一行代码也是干同样的事情。</p>
<pre><code class="assembly">mov    %ebx, [%esp+12] 
</code></pre>
<p>上面的代码将 ESP 寄存器的值加12个字节，再按照这个地址在 Stack 取出数据，这次取出的是<code>3</code>，将其写入 EBX 寄存器。</p>
<h3 id="5、add指令"><a href="#5、add指令" class="headerlink" title="5、add指令"></a>5、add指令</h3><p><code>add</code>指令用于将两个运算子相加，并将结果写入第一个运算子。</p>
<pre><code class="assembly">add    %eax, %ebx
</code></pre>
<p>上面的代码将 EAX 寄存器的值（即2）加上 EBX 寄存器的值（即3），得到结果5，再将这个结果写入第一个运算子 EAX 寄存器。</p>
<h3 id="6、pop指令"><a href="#6、pop指令" class="headerlink" title="6、pop指令"></a>6、pop指令</h3><p><code>pop</code>指令用于取出 Stack 最近一个写入的值（即最低位地址的值），并将这个值写入运算子指定的位置。</p>
<pre><code class="assembly">pop    %ebx
</code></pre>
<p>上面的代码表示，取出 Stack 最近写入的值（即 EBX 寄存器的原始值），再将这个值写回 EBX 寄存器（因为加法已经做完了，EBX 寄存器用不到了）。</p>
<p>注意，<code>pop</code>指令还会将 ESP 寄存器里面的地址加4，即回收4个字节。</p>
<h3 id="7、ret指令"><a href="#7、ret指令" class="headerlink" title="7、ret指令"></a>7、ret指令</h3><p><code>ret</code>指令用于终止当前函数的执行，将运行权交还给上层函数。也就是，当前函数的帧将被回收。</p>
<pre><code class="assembly">ret
</code></pre>
<p>可以看到，该指令没有运算子。</p>
<p>随着<code>add_a_and_b</code>函数终止执行，系统就回到刚才<code>main</code>函数中断的地方，继续往下执行。</p>
<pre><code class="assembly">add    %esp, 8 
</code></pre>
<p>上面的代码表示，将 ESP 寄存器里面的地址，手动加上8个字节，再写回 ESP 寄存器。这是因为 ESP 寄存器的是 Stack 的写入开始地址，前面的<code>pop</code>操作已经回收了4个字节，这里再回收8个字节，等于全部回收。</p>
<pre><code class="assembly">ret
</code></pre>
<p>最后，<code>main</code>函数运行结束，<code>ret</code>指令退出程序执行。</p>

        <!-- 分类文章 -->
        
          <div class="post-categoris-bottom">
            <div class="post-categoris-name">汇编语言</div>
            <ul>
            
            
              
            
            
            
              
            
            
            
              
                <li class="me base">
                  <a  href="/2022/04/18/%E6%B1%87%E7%BC%96%E5%85%A5%E9%97%A8/" class="post-categoris-bottom-link">
                  汇编入门
                </a>
                </li>
              
              
            
            
            
            
            </ul>

          </div>

        
      </div>
      <div class="post-content-inner-space">
        
          <div class="space-toc-main animate__animated  animate__fadeInUp">
            <ol class="space-toc"><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#%E4%B8%80-%E3%80%81%E6%9D%A5%E5%8E%86"><span class="space-toc-text">一 、来历</span></a></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#%E4%BA%8C%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8"><span class="space-toc-text">二、寄存器</span></a></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#%E4%B8%89%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="space-toc-text">三、寄存器的种类</span></a></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#%E5%9B%9B%E3%80%81%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="space-toc-text">四、内存模型</span></a></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#%E4%BA%94%E3%80%81CPU%E6%8C%87%E4%BB%A4"><span class="space-toc-text">五、CPU指令</span></a></li></ol>
           </div>
        
      </div>
   </div>
    <!-- 评论 -->
    
  </div>
</article>
  </div>
</div>



<!-- 如果是home模式的话，不在首页就显示footer，如果不是home模式的话 所有都显示footer -->

  <div class="footer-outer animate__animated  animate__fadeInUp">
    <div class="footer-inner">
    <div class="footer-text">
    <p>chase</p>

    </div>
    <div class="footer-contact">
    <ul class="footer-ul">
        
        <li class="footer-li">
            <a href="https://github.com/RgazHTale" target="_blank">
                <i class="ri-github-line"></i>
            </a>
        </li>
        
        <li class="footer-li">
            <a href="mailto:674260933@qq.com" target="_blank">
                <i class="ri-mail-line"></i>
            </a>
        </li>
        
    </ul>
    </div>
    </div>
</div>






<script src="/js/white.js"></script>



    
      
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.1/build/highlight.min.js"></script>

      <script>hljs.initHighlightingOnLoad();</script>
    

</body>
</html>
